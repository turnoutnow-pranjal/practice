"Hello and welcome to choose the right ^0^^ for modern applications as part of our added ^1^^ Summit online series ^2^^ My name is William Wong and I'm a ^3^^ database solutions architect ^4^^ And today I'll be joined by Michael Riccardi ^5^^ who's our specialist development solutions architect ^6^^ Today ^7^^ We're really excited to be here to show ^8^^ how purpose built databases could be used to ^9^^ the scale performance and availability of your applications ^10^^ our agenda will have an introduction of the ^11^^ from a modern day applications ^12^^ Will then look at the challenges that are ^13^^ using microservices and purpose built databases Before looking ^14^^ how we can go about picking up the ^15^^ databases for your particular workloads ^16^^ Michael ^17^^ We will then dive a bit deeper where ^18^^ modernize an app from a monolithic relational database ^19^^ to that of using purpose built databases and ^20^^ you the differences in both performance and scale ^21^^ So let's get started and look at the ^22^^ from our modern apps ^23^^ And we first look at the apps that ^24^^ each use every day like our ride sharing ^25^^ media , streaming , banking , gaming and ^26^^ media ^27^^ We begin to see some common patterns ^28^^ These patterns could be millions of users accessing ^29^^ apps across different geographies ^30^^ And these same users are expecting instant experiences ^31^^ could boil down to consistent millisecond or even ^32^^ millisecond response times ^33^^ Our apps will need to hyper scale to ^34^^ demands for events such as our flash sales ^35^^ urine processing and then scale back down ^36^^ We're not in use so that we can ^37^^ costs ^38^^ It is anticipated that will capture more data ^39^^ the next three years than that of the ^40^^ 30 years ^41^^ And this will need specialized tools to process ^42^^ petabytes ^43^^ If not zero bytes worth of structured and ^44^^ data ^45^^ If we take some time now and think ^46^^ the architectural patterns of most of these cloud ^47^^ apps , you'll find that they are all ^48^^  ^49^^ That means they are highly distributed , loosely ^50^^ and accessed via a P ^51^^ I ^52^^ S ^53^^ So what does that change in architecture mean ^54^^ our underlying database As our apps are now ^55^^ into services ^56^^ It allows each of these services to have ^57^^ own independent database ^58^^ And that'll bring us a lot of advantages ^59^^ for example , will give us the ability ^60^^ hyper scale our applications as each service and ^61^^ canal scale independently ^62^^ Let's take black friday as a use case ^63^^ We might need to scale our catalog and ^64^^ service to hundreds of thousands of concurrent requests ^65^^ a short time frame but our user registrations ^66^^ not grow to that same degree ^67^^ Another benefit is the added agility ^68^^ Since we can now innovate faster across different ^69^^  ^70^^ We can quickly test and roll back new ^71^^ and features on a modular level without dealing ^72^^ all the complex coupled dependencies which are related ^73^^ monoliths ^74^^ A common business challenge is making our apps ^75^^ available and by decoupling our databases , it ^76^^ increase its overall availability since we no longer ^77^^ a monolithic database which serves as that single ^78^^ of contention for our events such as code ^79^^ or upgrades and patches ^80^^ So now that we understand the advantages of ^81^^ our data ^82^^ T why would we consider purpose built databases ^83^^ our microservices ? Our developers want the right ^84^^ to meet the needs of our modern applications ^85^^ we described earlier ^86^^ And frankly that one size fits all approach ^87^^ using a relational database for everything , just ^88^^ longer works ^89^^ For example , we might need a database ^90^^ provide microsecond latency response times so that we ^91^^ quickly render our websites or to deliver consistent ^92^^ times to cater for a surgeon user demands ^93^^ And the relational architecture is not the best ^94^^ for these particular use cases ^95^^ In fact , by not using the right ^96^^ will typically lead to performance issues , lack ^97^^ scalability , lack of developer flexibility and an ^98^^ to our overall costs ^99^^ So traditionally , when I talk to my ^100^^ a barrier for adopting these purpose built databases ^101^^ a potential operational overheads ^102^^ And this included investments in upfront hardware and ^103^^ or expertise to make them scalable , highly ^104^^ and performant ^105^^ And this is where aws comes in ^106^^ We'll offer the broadest and deepest portfolio of ^107^^ plus purpose built databases that can support the ^108^^ data models by leveraging , purpose built and ^109^^ managed databases that we built from the ground ^110^^ customers can now save time and costs , ^111^^ performance at scale and innovate faster ^112^^ We have purpose built databases to match every ^113^^ case like relational key value document in memory ^114^^ wide column time series ledger and our graph ^115^^  ^116^^ So now that we understand the need for ^117^^ built databases , how then would you go ^118^^ selecting the right databases for your particular use ^119^^ ? What I'd like to tell people is ^120^^ of looking at a list of 100 different ^121^^ , why don't we start off by thinking ^122^^ common database categories ? So now we quickly ^123^^ across the categories ^124^^ Not only would you find that familiar relational ^125^^ there on the left , but you'll also ^126^^ other databases , databases like our amazon document ^127^^ which is optimized for storing the data in ^128^^ format ^129^^ And since it's a no sequel database , ^130^^ will give us that flexibility around changing application ^131^^ but it will also allow us to query ^132^^ based on any attribute ^133^^ And this is really handy for our content ^134^^ or mobile apps or a graph database like ^135^^ Neptune , which then allows us to work ^136^^ highly connected data sets ^137^^ We can try to model this out in ^138^^ relational database with complicated joints and nested queries ^139^^ our latency is will grow as a number ^140^^ our relationships increase in graph databases ^141^^ However , it allows us to traverse millions ^142^^ relationships in seconds , which is great for ^143^^ detection , social media and our recommendation engines ^144^^ Well lastly like a time series database like ^145^^ amazon time stream which is optimized to ingest ^146^^ of time sequence data a day as well ^147^^ giving us time based functions such as correlation ^148^^ interpolation so that we can gain better insights ^149^^ that data ^150^^ And this is great for our IOT devops ^151^^ event tracking apps ^152^^ Let's take some time now to dive a ^153^^ further into some very common categories that I've ^154^^ amongst my customers ^155^^ Let's start off with a really familiar relational ^156^^ model , relational data is highly structured and ^157^^ data is broken up into tables and the ^158^^ enforced by the system are primary and referential ^159^^ and good use cases for them will be ^160^^ where we can't predefined all our access patterns ^161^^ front or if we had apps that requires ^162^^ referential integrity and strong consistency ^163^^ Like for our online payment systems ^164^^ A cloud native database we could choose for ^165^^ relational models is amazon Arora ^166^^ Arora is compatible with both my sequel and ^167^^ and can help us enhance our performance by ^168^^ up to five times more throughput than that ^169^^ standard ^170^^ My sequel and three times more than that ^171^^ standard Postgres ^172^^ It will help us automatically scale both compute ^173^^ storage resources and we drew billy store our ^174^^ six ways across three availability zones ^175^^ And since it's a managed service will provide ^176^^ automation for tasks such as deployment and provisioning ^177^^ patching and upgrades , backups and give us ^178^^ features like encryption in transit and at rest ^179^^ Another great category ^180^^ To look at our our key value databases ^181^^ Key value data is one that uses that ^182^^ key value method to store and retrieve data ^183^^ its strength lies behind its design to highly ^184^^ or shard data and then physically store it ^185^^ on that partition key ^186^^ That design allows it to horizontally scale to ^187^^ any size while still giving us consistent response ^188^^ , irrespective of scale ^189^^ So let's go through a use case for ^190^^ "