« Bonjour et bienvenue à choisir le bon ^0. pour les applications modernes dans le cadre de notre ^1 ajouté. Série Summit en ligne ^2. Je m'appelle William Wong et je suis un architecte de solutions de base de données ^3. ^4. Et aujourd'hui, je serai rejoint par Michael Riccardi ^5, notre architecte spécialisé dans les solutions de développement ^6. Aujourd'hui ^7. Nous sommes très heureux d'être ici pour montrer à ^8. comment des bases de données spécialement conçues peuvent être utilisées pour ^9. L'échelle, les performances et la disponibilité de vos applications ^10. notre agenda comportera une introduction du ^11. à partir d'applications modernes ^12. J'examinerai ensuite les défis liés à ^13. L'utilisation de microservices et de bases de données spécialisées. Avant d'examiner ^14, comment nous pouvons procéder pour sélectionner les bases de données ^15 pour vos charges de travail particulières ^16. Michael ^17. Nous allons ensuite plonger un peu plus en profondeur où ^18. moderniser une application d'une base de données relationnelle monolithique ^19. à celle utilisant des bases de données spécialement conçues et ^20. vous les différences en termes de performances et d'échelle ^21. Commençons donc et examinons le ^22. de nos applications modernes ^23. Et nous examinons d'abord les applications que ^24 utilisent tous les jours, comme notre service de covoiturage ^25, les médias, le streaming, les services bancaires, les jeux et ^26, les médias ^27. Nous commençons à voir quelques modèles courants ^28. Ces modèles peuvent être des millions d'utilisateurs accédant à ^29. applications dans différentes zones géographiques ^30. Et ces mêmes utilisateurs s'attendent à des expériences instantanées ^31. qui pourraient se résumer à des temps de réponse constants en millisecondes, voire ^32 millisecondes ^33. Nos applications devront être hyperdimensionnées pour atteindre ^34 demandes pour des événements tels que nos ventes flash ^35. le traitement de l'urine, puis diminuer ^36. Nous ne sommes pas utilisés, donc nous pouvons ^37. coûte ^38. Il est prévu de capturer plus de données ^39 au cours des trois prochaines années que celles des ^40. 30 ans^41. Et cela nécessitera des outils spécialisés pour traiter ^42 pétaoctets ^43. Sinon, zéro octet de données structurées et ^44. données ^45. Si nous prenons le temps de réfléchir à ^46 aux modèles architecturaux de la plupart de ces applications cloud ^47, vous constaterez qu'elles sont toutes ^48. ^49. Cela signifie qu'ils sont très distribués, vaguement ^50. et accessibles via un P ^51. DANS ^52. S ^53. Alors, que signifie ce changement d'architecture ^54. Notre base de données sous-jacente Comme nos applications sont maintenant ^55. en services ^56. Cela permet à chacun de ces services d'avoir ^57. propre base de données indépendante ^58. Et cela nous apportera de nombreux avantages ^59. Par exemple, cela nous donnera la capacité ^60. à hyperdimensionner nos applications pour chaque service et ^61. À l'échelle du canal de manière indépendante ^62. Prenons le Black Friday comme cas d'utilisation ^63. Il se peut que nous ayons besoin d'étendre notre catalogue et ^64. service à des centaines de milliers de demandes simultanées ^65. Dans un court laps de temps, mais nos inscriptions d'utilisateurs ^66. ne croissent pas au même degré ^67. Un autre avantage est l'agilité supplémentaire ^68. Puisque nous pouvons désormais innover plus rapidement sur différents ^69. ^70. Nous pouvons rapidement tester et restaurer de nouveaux ^71. et de nouvelles fonctionnalités à un niveau modulaire sans traiter ^72. Toutes les dépendances couplées complexes qui sont liées ^73. monolithes ^74. L'un des défis commerciaux courants consiste à rendre nos applications ^75. disponibles et en découplant nos bases de données, cela ^76. augmente leur disponibilité globale puisque nous n'avons plus ^77. une base de données monolithique qui sert de ^78. de conflit unique pour nos événements tels que le code ^79. ou les mises à niveau et les correctifs ^80. Maintenant que nous comprenons les avantages de ^81. Nos données ^82. Pourquoi considérerions-nous des bases de données spécialement conçues ^83. Nos microservices ? Nos développeurs veulent le bon ^84. pour répondre aux besoins de nos applications modernes ^85. Nous avons décrit précédemment ^86. Et franchement, cette approche universelle ^87. En utilisant une base de données relationnelle pour tout, juste ^88. Plus long fonctionne ^89. Par exemple, nous pouvons avoir besoin d'une base de données ^90. Fournissez des temps de réponse de latence de l'ordre de la microseconde afin que nous ^91. affichions rapidement nos sites Web ou que nous puissions fournir des délais ^92 cohérents pour répondre aux demandes ^93 d'un utilisateur chirurgien. Et l'architecture relationnelle n'est pas la meilleure ^94. pour ces cas d'utilisation particuliers ^95. En fait, le fait de ne pas utiliser le bon ^96. entraînera généralement des problèmes de performance, un manque de ^97. d'évolutivité, un manque de flexibilité pour les développeurs et un ^98. de nos coûts globaux ^99. Donc, traditionnellement, quand je parle à mon ^100, un obstacle à l'adoption de ces bases de données spécialement conçues ^101. Des frais généraux opérationnels potentiels ^102. Cela comprenait des investissements dans du matériel initial et ^103. ou une expertise pour les rendre évolutifs, hautement ^104. et performants ^105. Et c'est là qu'AWS entre en jeu ^106. Nous proposerons le portefeuille le plus large et le plus complet de ^107, ainsi que des bases de données spécialisées capables de prendre en charge les ^108. modèles de données en tirant parti des bases de données personnalisées et ^109. gérées que nous avons créées à partir de zéro ^110. les clients peuvent désormais gagner du temps et de l'argent, ^111. des performances à grande échelle et innover plus rapidement ^112. Nous avons créé des bases de données spécialement conçues pour correspondre à chaque ^113 cas, comme un document de valeur clé relationnelle en mémoire ^114. Un registre de séries chronologiques à colonnes larges et notre graphique ^115. ^116. Maintenant que nous comprenons la nécessité de ^117 bases de données construites, comment procéderiez-vous ^118. en sélectionnant les bonnes bases de données pour votre usage particulier ^119. ? Ce que j'aimerais dire aux gens, c'est ^120. en regardant une liste de 100 ^121 différents. Pourquoi ne pas commencer par penser à ^122. Catégories de bases de données courantes ? Alors maintenant, nous avons rapidement ^123. à travers les catégories ^124. Non seulement vous trouverez ce ^125 relationnel familier sur la gauche, mais vous trouverez également ^126. D'autres bases de données, des bases de données comme notre document Amazon ^127. qui est optimisé pour stocker les données au format ^128. ^129. Et comme il s'agit d'une base de données sans suite, ^130. nous donnera la flexibilité nécessaire pour modifier l'application ^131. mais cela nous permettra également d'interroger ^132. en fonction de n'importe quel attribut ^133. Et c'est très pratique pour notre contenu ^134. ou pour les applications mobiles ou pour une base de données de graphes telle que ^135. Neptune, qui nous permet ensuite de travailler ^136. Des ensembles de données hautement connectés ^137. Nous pouvons essayer de modéliser cela dans ^138. Base de données relationnelle avec des articulations compliquées et des requêtes imbriquées ^139. Notre latence augmentera au fur et à mesure que le nombre ^140. Nos relations augmentent dans les bases de données graphiques ^141. Cependant, cela nous permet de parcourir des millions ^142. relations en quelques secondes, ce qui est idéal pour ^143. La détection, les réseaux sociaux et nos moteurs de recommandation ^144. Enfin, comme une base de données de séries chronologiques comme ^145. Amazon Time Stream qui est optimisée pour ingérer ^146. de données de séquence temporelle par jour également ^147. nous donnant des fonctions basées sur le temps telles que la corrélation ^148. interpolation afin que nous puissions obtenir de meilleures informations ^149. ces données ^150. Et c'est idéal pour nos applications de suivi d'événements IOT DevOps ^151. ^152. Prenons maintenant le temps de plonger ^153. Plus loin dans certaines catégories très courantes que j'ai ^154 parmi mes clients ^155. Commençons par un modèle relationnel ^156 très familier, les données relationnelles sont hautement structurées et ^157. Les données sont divisées en tables et les ^158. imposés par le système sont primaires et référentiels ^159. Et les bons cas d'utilisation pour celles-ci seront ^160. où nous ne pouvons pas prédéfinir tous nos modèles d'accès ^161. avant ou si nous avions des applications qui nécessitent ^162. Une intégrité référentielle et une forte cohérence ^163. Comme pour nos systèmes de paiement en ligne ^164. Une base de données cloud native que nous pourrions choisir pour ^165. Les modèles relationnels sont Amazon Arora ^166. Arora est compatible à la fois avec ma suite et ^167. et peut nous aider à améliorer nos performances de ^168. jusqu'à cinq fois plus de débit que le ^169. standard ^170. Ma suite et trois fois plus que ça ^171. Postgres standard ^172. Cela nous aidera à dimensionner automatiquement les ressources de calcul ^173. Et nous avons dessiné Billy Store notre ^174 de six manières différentes dans trois zones de disponibilité ^175. Et comme il s'agit d'un service géré, il fournira ^176. L'automatisation de tâches telles que le déploiement et le provisionnement ^177. L'application de correctifs et de mises à niveau, les sauvegardes et nous fournira ^178 fonctionnalités telles que le chiffrement en transit et au repos ^179. Une autre excellente catégorie ^180. Pour consulter nos bases de données de valeurs clés ^181. Les données de valeur clé sont celles qui utilisent cette méthode ^182. La valeur clé pour stocker et récupérer les données ^183. Sa force réside dans sa conception à ^184. ou à partager des données, puis à les stocker physiquement ^185. sur cette clé de partition ^186. Cette conception lui permet de s'adapter horizontalement à ^187, n'importe quelle taille, tout en nous donnant une réponse cohérente ^188., quelle que soit l'échelle ^189. Passons donc en revue un cas d'utilisation pour ^190. «